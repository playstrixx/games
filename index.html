<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khushi vs Shubham: Cross & Zero (Dare Edition)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Pacifico&display=swap');
        
        /* Base Styles and Colors */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Very Dark Background */
            color: #c9d1d9; /* Light Gray Text */
            padding: 1rem;
        }
        .container {
            width: 100%;
            background-color: #161b22; /* Darker Container Background */
            padding: 1.5rem;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.05);
        }
        h1 {
            font-family: 'Inter', sans-serif; 
            font-weight: 900;
        }
        h2 {
            font-family: 'Pacifico', cursive; 
            color: #58a6ff; /* Neon Blue Accent */
        }

        /* Competitive Title Styling */
        .vs-title {
            font-size: 2.25rem;
            line-height: 2.5rem;
            text-align: center;
        }
        @media (min-width: 640px) {
            .vs-title {
                font-size: 3rem;
                line-height: 1;
            }
        }

        .shubham-color { color: #58a6ff; } /* Blue/Cyan */
        .khushi-color { color: #ff7aa2; } /* Pink/Rose */
        .vs-comp {
            color: #f85149; /* Bright Red */
            text-shadow: 0 0 10px rgba(248, 81, 73, 0.8);
            padding: 0 0.5rem;
        }

        /* Board Styles */
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            margin: 1.5rem 0;
            border-radius: 12px;
            padding: 10px;
            background: #0d1117; /* Background for the board area */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }
        .cell {
            aspect-ratio: 1 / 1;
            background-color: #21262d; /* Cell Background */
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            font-weight: 900;
            cursor: pointer;
            transition: background-color 0.15s, transform 0.15s, box-shadow 0.15s;
            color: #c9d1d9; 
            user-select: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        .cell:hover:not(.disabled) {
            background-color: #30363d;
            transform: scale(1.03); 
            box-shadow: 0 0 12px rgba(88, 166, 255, 0.5); /* Blue glow on hover */
        }
        .cell.disabled { cursor: default; }

        /* Mark Styles */
        /* Shubham is X - Normal X symbol */
        .cell.mark-X { color: #58a6ff; } 
        /* Khushi is Hello Kitty (O) */
        .cell.mark-O img {
            width: 80%;
            height: 80%;
            object-fit: contain;
            border-radius: 50%;
            animation: popIn 0.3s ease-out;
        }
        .cell.mark-X { animation: popIn 0.3s ease-out; }
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            80% { transform: scale(1.1); }
            100% { transform: scale(1.0); opacity: 1; }
        }

        /* Modal/Overlay Styles */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 17, 23, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease-out;
        }
        .win-card {
            background: #161b22;
            padding: 2rem;
            border-radius: 16px;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 0 30px rgba(255, 122, 162, 0.7); /* Pink Neon Glow */
            border: 2px solid #ff7aa2;
            animation: bounceIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes bounceIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .modal-message {
            font-family: 'Pacifico', cursive;
            font-size: 1.5rem;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
        }
        .score-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 1.5rem;
            background-color: #0d1117;
            padding: 0.75rem;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        .score-box {
            text-align: center;
            font-size: 1.1rem;
            color: #c9d1d9;
        }
        .score-value {
            font-family: 'Pacifico', cursive;
            font-size: 2.2rem;
            font-weight: bold;
            color: #fbd38d;
            margin-top: 0.25rem;
        }

        /* History Table Styling */
        .history-table th {
            color: #58a6ff;
            border-bottom: 2px solid #58a6ff;
        }
        .history-table td {
            border-top: 1px solid #30363d;
        }
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, getDoc, updateDoc, collection, query, limit, orderBy, addDoc, where, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Permanent Firebase Configuration (Provided by user for project 'games-1c1f5')
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyCnGV3jAxfcVze11wSfW_NzIS3z0rF8p6c",
            authDomain: "games-1c1f5.firebaseapp.com",
            projectId: "games-1c1f5",
        };
        const APP_ID = FIREBASE_CONFIG.projectId; 

        let app, db, auth, userId = null;
        let currentGameId = null;
        let playerMark = null; // 'X' or 'O'
        let unsubscribeGame = null;
        let unsubscribeCodes = null;
        let lastGameStatus = null; 
        let isGameReady = false;

        // ROLES: Shubham creates (X), Khushi joins (O)
        const PLAYER_NAMES = {
            'X': 'Shubham', // Creator (Star)
            'O': 'Khushi'   // Joiner (Hello Kitty)
        };
        const WINNING_SCORE = 5;
        const KITTY_IMAGE_URL = "https://i.ibb.co/39txdnyX/images.webp";
        const API_KEY = ""; // Kept empty for Canvas environment or use of TTS/Image APIs

        const ui = {
            gameIdInput: document.getElementById('gameIdInput'),
            userIdDisplay: document.getElementById('userIdDisplay'),
            lobbySection: document.getElementById('lobbySection'),
            gameSection: document.getElementById('gameSection'),
            createGameBtn: document.getElementById('createGameBtn'),
            joinGameBtn: document.getElementById('joinGameBtn'),
            gameStatus: document.getElementById('gameStatus'),
            boardContainer: document.getElementById('boardContainer'),
            yourPlayerName: document.getElementById('yourPlayerName'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            shubhamScoreDisplay: document.getElementById('shubhamScore'),
            khushiScoreDisplay: document.getElementById('khushiScore'),
            historyBody: document.getElementById('historyBody'),
            winOverlay: document.getElementById('winOverlay'),
            modalTitle: document.getElementById('modalTitle'),
            modalMessage: document.getElementById('modalMessage'),
            modalButton: document.getElementById('modalButton'),
            lobbyStatus: document.getElementById('lobbyStatus'),
            gameCodeDisplay: document.getElementById('gameCodeDisplay'),
            statusBox: document.getElementById('statusBox'), // New container for status/code
        };

        const COLLECTIONS = {
            games: `artifacts/${APP_ID}/public/data/tictactoe_games_shubham_khushi_tts`,
            history: `artifacts/${APP_ID}/public/data/game_history`,
            codes: `artifacts/${APP_ID}/public/data/game_codes`
        };

        // --- Utility Functions ---

        const setLoading = (isLoading) => {
            ui.loadingOverlay.style.display = isLoading ? 'flex' : 'none';
        };

        const showMessage = (msg, colorClass) => {
            ui.gameStatus.textContent = msg;
            ui.gameStatus.className = `status-message ${colorClass}`;
        };

        const getPlayerName = (mark) => PLAYER_NAMES[mark] || mark;
        const getOpponentName = (mark) => PLAYER_NAMES[mark === 'X' ? 'O' : 'X'] || (mark === 'X' ? 'O' : 'X');

        const checkWinner = (board) => {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a]; // Returns 'X' or 'O'
                }
            }

            if (board.every(cell => cell !== "")) {
                return 'DRAW';
            }

            return null;
        };
        
        // --- Access Code System ---
        const generateCode = () => {
            const words = ["LOVE", "HUG", "CUTE", "STAR", "ROSE", "HEART", "KISS", "KITT", "MWAH", "XOXO"];
            return words[Math.floor(Math.random() * words.length)];
        };

        const findGameIdByCode = async (code) => {
            const codesRef = collection(db, COLLECTIONS.codes);
            const q = query(codesRef, where("code", "==", code.toUpperCase()), limit(1));
            const snapshot = await getDocs(q);
            if (!snapshot.empty) {
                return snapshot.docs[0].data().gameId;
            }
            return null;
        };

        // --- TTS Helper Functions ---
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bytesPerSample = 2; // Int16
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            
            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);
            
            let offset = 0;

            const writeString = (s) => {
                for (let i = 0; i < s.length; i++) {
                    view.setUint8(offset + i, s.charCodeAt(i));
                }
                offset += s.length;
            };

            // RIFF chunk
            writeString('RIFF');
            view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4;
            writeString('WAVE');

            // fmt chunk
            writeString('fmt ');
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size
            view.setUint16(offset, 1, true); offset += 2;  // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, 16, true); offset += 2; // BitsPerSample (16)

            // data chunk
            writeString('data');
            view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4;

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        };

        const callTTSApi = async (text, voiceName = "Zephyr") => {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voiceName }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`TTS API failed: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 16000;
                        
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        
                        const audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.play();
                        return;
                    }
                } catch (error) {
                    // console.error(`TTS attempt ${attempt + 1} failed:`, error);
                    if (attempt < 2) {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                    }
                }
            }
            // console.error("TTS failed after all retries.");
        };


        // --- UI Rendering ---

        const renderBoard = (board, game) => {
            ui.boardContainer.innerHTML = '';
            board.forEach((mark, index) => {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                
                if (mark === 'X') {
                    cell.classList.add('mark-X');
                    cell.textContent = 'X';
                } else if (mark === 'O') {
                    cell.classList.add('mark-O');
                    const img = document.createElement('img');
                    img.src = KITTY_IMAGE_URL; 
                    img.alt = 'Khushi/Hello Kitty';
                    cell.appendChild(img);
                }

                const isPlayable = game.status === 'IN_PROGRESS' && game.turn === playerMark;
                const isEmpty = mark === "";
                
                if (isPlayable && isEmpty) {
                    cell.onclick = () => handleCellClick(index);
                } else {
                    cell.classList.add('disabled');
                }

                ui.boardContainer.appendChild(cell);
            });
        };
        
        const showWinOverlay = (title, message, isSeriesWin, onContinue) => {
            ui.modalTitle.textContent = title;
            ui.modalMessage.innerHTML = message; 
            ui.modalButton.textContent = isSeriesWin ? "Start New Game Series" : "Play Next Round";
            ui.modalButton.onclick = () => {
                ui.winOverlay.classList.add('hidden');
                onContinue();
            };
            ui.winOverlay.classList.remove('hidden');
        }


        const renderGameUI = (game) => {
            const { board, turn, status, khushiWins, shubhamWins, playerOId } = game;

            // --- Status Box Update ---
            if (playerMark) {
                const code = ui.gameCodeDisplay.textContent;
                let statusText = "";
                let statusClass = "text-yellow-500";
                
                if (status === 'LOBBY' && !playerOId) {
                    statusText = `Waiting for Khushi to join...`;
                } else if (status === 'LOBBY' && playerOId) {
                     statusText = `Khushi is Connected! Game starting...`;
                     statusClass = "text-green-500";
                } else if (status === 'IN_PROGRESS') {
                    statusText = `Khushi is Connected!`;
                    statusClass = "text-green-500";
                }
                
                ui.lobbyStatus.innerHTML = statusText;
                ui.gameCodeDisplay.textContent = code;
                ui.lobbyStatus.className = statusClass + ' font-bold';
            }
            
            // Update UI visibility
            ui.lobbySection.classList.add('hidden');
            ui.gameSection.classList.remove('hidden');
            ui.yourPlayerName.textContent = getPlayerName(playerMark);
            ui.shubhamScoreDisplay.textContent = shubhamWins;
            ui.khushiScoreDisplay.textContent = khushiWins;
            
            let message = "";
            let colorClass = "bg-gray-700 text-gray-200";
            
            // --- Determine Series Win ---
            const isSeriesOver = shubhamWins >= WINNING_SCORE || khushiWins >= WINNING_SCORE;
            const seriesWinnerMark = shubhamWins >= WINNING_SCORE ? 'X' : khushiWins >= WINNING_SCORE ? 'O' : null;

            if (isSeriesOver) {
                if (lastGameStatus !== status) {
                    const winnerName = getPlayerName(seriesWinnerMark);
                    const loserName = getOpponentName(seriesWinnerMark);
                    
                    showWinOverlay(
                        "üéâ SERIES VICTORY! üéâ",
                        `The score is ${shubhamWins} vs ${khushiWins}. **${winnerName}** wins the series! <br><br> Time for a dare! **${winnerName}** must give **${loserName}** a dare!`,
                        true,
                        () => resetRound(false) // Reset scores
                    );
                }
                message = "Game Over! Time for a dare.";
                colorClass = "bg-purple-600 text-white";
            } else if (status === 'X_WINS' || status === 'O_WINS' || status === 'DRAW') {
                const winnerMark = status === 'X_WINS' ? 'X' : status === 'O_WINS' ? 'O' : null;
                const winnerName = winnerMark ? getPlayerName(winnerMark) : null;
                
                // --- Custom Win Messages for Round Win ---
                let modalTitle = status === 'DRAW' ? "ü§ù ROUND DRAW ü§ù" : "üèÜ ROUND WIN! üèÜ";
                let modalMessage;
                let ttsMessage; 

                if (winnerMark === 'X') { // Shubham (X) won
                    if (playerMark === 'X') { // Shubham's Screen (Winner)
                        modalMessage = "Khushi hi jiti hai ü•∫"; 
                    } else { // Khushi's Screen (Loser)
                        modalMessage = "Cutie tmhi jiti ho üòç"; 
                    }
                    ttsMessage = "Shubham won the round, but Khushi is still the cutest!";
                } else if (winnerMark === 'O') { // Khushi (O) won
                    modalMessage = "Aww, Khushi won this round! Cutie tmhi jiti ho! ‚ú®";
                    ttsMessage = "Aww, Khushi won this round! Congratulations!";
                } else {
                    modalMessage = "You both fought hard! Great match.";
                    ttsMessage = "It's a draw. Get ready for the next round!";
                }
                
                // Show modal only if status just changed
                if (lastGameStatus !== status) {
                     showWinOverlay(
                        modalTitle,
                        modalMessage,
                        false,
                        () => resetRound(true) // Keep scores
                    );
                    
                    // Play sound on both screens, but only once per status change
                    if (status !== 'DRAW') {
                        callTTSApi(ttsMessage);
                        recordGameHistory(winnerName, getOpponentName(winnerMark)); // Record history once
                    }
                }

                message = modalTitle;
                colorClass = (winnerMark === playerMark) ? "bg-green-500 text-white" : "bg-red-500 text-white";
                
            } else {
                // Game in progress or lobby
                if (status === 'LOBBY' && !playerOId && playerMark === 'X') {
                    message = `Share your code: ${ui.gameCodeDisplay.textContent}`;
                    colorClass = "bg-yellow-700 text-yellow-200";
                } else if (status === 'IN_PROGRESS') {
                    if (turn === playerMark) {
                        message = `Your turn, ${getPlayerName(playerMark)}!`;
                        colorClass = "bg-pink-700 text-pink-200";
                    } else {
                        message = `Waiting for ${getPlayerName(turn)} to move...`;
                        colorClass = "bg-blue-700 text-blue-200";
                    }
                } else if (status === 'LOBBY' && playerOId) {
                     message = "Game ready! Shubham starts.";
                     colorClass = "bg-green-700 text-green-200";
                } else if (status === 'LOBBY' && playerMark === 'O') {
                     message = "Joined game. Waiting for Shubham to start the round.";
                     colorClass = "bg-green-700 text-green-200";
                }
            }
            
            // Only update the continuous status message if the modal is NOT showing
            if (ui.winOverlay.classList.contains('hidden')) {
                showMessage(message, colorClass);
            }
            
            renderBoard(board, game);
            lastGameStatus = status; // Update status tracker
        };


        // --- Firestore Operations ---

        const getGameDocRef = (id) => doc(db, COLLECTIONS.games, id);

        const recordGameHistory = async (winnerName, loserName) => {
            try {
                // Look for existing records to prevent duplication during real-time sync
                const q = query(collection(db, COLLECTIONS.history), 
                    where("gameId", "==", currentGameId),
                    where("timestamp", ">", Date.now() - 30000) // Look back 30 seconds
                );
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    await addDoc(collection(db, COLLECTIONS.history), {
                        gameId: currentGameId,
                        winner: winnerName,
                        loser: loserName,
                        timestamp: Date.now()
                    });
                }
            } catch (e) {
                console.error("Error recording history:", e);
            }
        };

        const renderHistory = (snapshot) => {
            ui.historyBody.innerHTML = '';
            
            // Sort in memory by timestamp descending
            let history = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                history.push(data);
            });

            history.sort((a, b) => b.timestamp - a.timestamp);
            history = history.slice(0, 20); // Keep only the latest 20

            if (history.length === 0) {
                 ui.historyBody.innerHTML = '<tr><td colspan="4" class="p-4 text-center text-gray-500">No games recorded yet. Start challenging!</td></tr>';
                 return;
            }

            history.forEach((game, index) => {
                // Safely handle potential missing data (fixes undefined issue)
                const winner = game.winner || 'N/A';
                const loser = game.loser || 'N/A';
                const timestamp = game.timestamp || 0;
                
                const date = new Date(timestamp).toLocaleTimeString();
                const winnerClass = winner === 'Khushi' ? 'khushi-color' : 'shubham-color';
                
                const row = `
                    <tr class="text-sm">
                        <td class="p-2 text-gray-400">${index + 1}</td>
                        <td class="p-2 font-bold ${winnerClass}">${winner}</td>
                        <td class="p-2">${loser}</td>
                        <td class="p-2 text-gray-500">${date}</td>
                    </tr>
                `;
                ui.historyBody.innerHTML += row;
            });
        };

        const createGame = async () => {
            const cuteCode = generateCode();
            
            currentGameId = userId; // Actual document ID is still the UID
            playerMark = 'X'; // Creator is Shubham (X)
            setLoading(true);

            const initialGame = {
                board: ["", "", "", "", "", "", "", "", ""],
                currentPlayer: 'X',
                status: 'LOBBY',
                playerXId: userId,
                playerOId: null,
                turn: 'X',
                shubhamWins: 0,
                khushiWins: 0,
                lastUpdated: Date.now()
            };

            try {
                // 1. Create the main game document
                await setDoc(getGameDocRef(currentGameId), initialGame);
                
                // 2. Map the cute code to the actual game ID (UID)
                await setDoc(doc(db, COLLECTIONS.codes, cuteCode), {
                    code: cuteCode,
                    gameId: currentGameId,
                    creatorId: userId,
                    timestamp: Date.now()
                });

                ui.gameCodeDisplay.textContent = cuteCode;
                startRealTimeListener(currentGameId);
                startLobbyListener(currentGameId);
                
                // Update the lobby status display for the creator
                ui.lobbySection.classList.add('hidden');
                ui.gameSection.classList.remove('hidden');
                ui.yourPlayerName.textContent = getPlayerName(playerMark);
                
                showMessage(`Game created! Share this code: ${cuteCode}`, 'bg-teal-700 text-teal-200');

            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Error creating game. See console.", 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        const joinGame = async (code) => {
            if (!code) {
                showMessage("Please enter the Cute Code.", 'bg-red-700 text-red-200');
                return;
            }

            setLoading(true);
            
            try {
                // 1. Find the actual Game ID (UID) using the cute code
                const gameId = await findGameIdByCode(code.toUpperCase());

                if (!gameId) {
                    showMessage("Invalid Code or Game Not Found.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }
                
                currentGameId = gameId;
                const gameRef = getGameDocRef(gameId);
                const docSnap = await getDoc(gameRef);

                if (!docSnap.exists()) {
                    showMessage("Game not found or invalid ID.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }

                const game = docSnap.data();

                if (game.playerXId === userId) {
                    playerMark = 'X'; // Rejoining as Shubham
                    ui.gameCodeDisplay.textContent = code.toUpperCase();
                    startRealTimeListener(gameId);
                    return;
                }

                if (game.playerOId && game.playerOId !== userId) {
                    showMessage("Game already full.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }

                // Joining as Khushi (O)
                playerMark = 'O';
                await updateDoc(gameRef, {
                    playerOId: userId,
                    status: 'IN_PROGRESS'
                });
                ui.gameCodeDisplay.textContent = code.toUpperCase();
                startRealTimeListener(gameId);

            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Error joining game. See console.", 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        const handleCellClick = async (index) => {
            if (!currentGameId || !playerMark) return;

            setLoading(true);
            const gameRef = getGameDocRef(currentGameId);
            const docSnap = await getDoc(gameRef);
            
            if (!docSnap.exists()) { setLoading(false); return; }
            
            const game = docSnap.data();
            const { board, turn, status } = game;

            if (status !== 'IN_PROGRESS' || turn !== playerMark || board[index] !== "") {
                setLoading(false);
                return; 
            }

            // 1. Update the board
            const newBoard = [...board];
            newBoard[index] = playerMark;

            // 2. Check for winner/draw
            const winner = checkWinner(newBoard);
            let newStatus = 'IN_PROGRESS';
            let nextTurn = playerMark === 'X' ? 'O' : 'X';
            
            let shubhamWins = game.shubhamWins;
            let khushiWins = game.khushiWins;

            if (winner === 'DRAW') {
                newStatus = 'DRAW';
                nextTurn = null; 
            } else if (winner) {
                newStatus = winner === 'X' ? 'X_WINS' : 'O_WINS';
                if (winner === 'X') shubhamWins++;
                else khushiWins++;
                nextTurn = null; 
            }

            // 3. Commit the state update
            try {
                await updateDoc(gameRef, {
                    board: newBoard,
                    turn: nextTurn,
                    status: newStatus,
                    shubhamWins: shubhamWins,
                    khushiWins: khushiWins,
                    lastUpdated: Date.now()
                });
            } catch (e) {
                console.error("Error making move:", e);
                showMessage("Move failed. Try again.", 'bg-red-700 text-red-200');
            } finally {
                setLoading(false);
            }
        };
        
        const resetRound = async (keepScore = true) => {
            if (!currentGameId) return;
            setLoading(true);

            const gameRef = getGameDocRef(currentGameId);
            const updateData = {
                board: ["", "", "", "", "", "", "", "", ""],
                status: 'IN_PROGRESS',
                turn: 'X', // X always starts the next round
                lastUpdated: Date.now()
            };

            if (!keepScore) {
                updateData.shubhamWins = 0;
                updateData.khushiWins = 0;
                // Delete the code mapping to allow a new game series to be created later
                try {
                    const codesRef = collection(db, COLLECTIONS.codes);
                    const q = query(codesRef, where("gameId", "==", currentGameId));
                    const snapshot = await getDocs(q);
                    if (!snapshot.empty) {
                        snapshot.docs.forEach(async doc => {
                            // Only delete the code mapping if we are resetting the series
                            if (!keepScore) await deleteDoc(doc.ref);
                        });
                    }
                } catch (e) {
                    console.error("Failed to delete old code mapping:", e);
                }
            }

            try {
                await updateDoc(gameRef, updateData);
                lastGameStatus = null; // Reset status tracker for next round
                
                // If scores were reset (series victory), hide the game section for the creator
                if (!keepScore && playerMark === 'X') {
                    currentGameId = null;
                    ui.lobbySection.classList.remove('hidden');
                    ui.gameSection.classList.add('hidden');
                    showMessage("Series finished. Ready to create a new game!", 'bg-teal-700 text-teal-200');
                }
            } catch (error) {
                console.error("Error resetting game/round:", error);
            } finally {
                setLoading(false);
            }
        }


        // --- Real-Time Listeners ---

        const startRealTimeListener = (gameId) => {
            // Stop previous listener if active
            if (unsubscribeGame) {
                unsubscribeGame();
            }

            const gameRef = getGameDocRef(gameId);
            
            unsubscribeGame = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const game = docSnap.data();
                    renderGameUI(game);
                    if (game.status !== 'LOBBY' || game.playerOId || game.playerXId) {
                        setLoading(false);
                    }
                } else {
                    showMessage("Game deleted or disconnected.", 'bg-red-700 text-red-200');
                    // Optionally reset to lobby
                }
            }, (error) => {
                console.error("Firestore snapshot error:", error);
                showMessage("Connection error. Try refreshing.", 'bg-red-700 text-red-200');
                setLoading(false);
            });
        };

        const startHistoryListener = () => {
            const historyRef = collection(db, COLLECTIONS.history);
            // Query for the latest 20 games
            const q = query(historyRef, orderBy("timestamp", "desc"), limit(20));

            onSnapshot(q, (snapshot) => {
                renderHistory(snapshot);
            }, (error) => {
                console.error("History listener error:", error);
            });
        };

        // Lobby listener for Khushi's connection status (only needed by creator X)
        const startLobbyListener = (gameId) => {
            if (unsubscribeCodes) unsubscribeCodes(); // Stop any previous listener
            
            const gameRef = getGameDocRef(gameId);
            
            unsubscribeCodes = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const game = docSnap.data();
                    if (game.playerOId) {
                        ui.lobbyStatus.textContent = "Khushi is Connected! üéÄ Game Ready!";
                        ui.lobbyStatus.className = "text-green-500 font-bold";
                        if (unsubscribeCodes) unsubscribeCodes(); // Stop listening once connected
                    } else if (playerMark === 'X') {
                        ui.lobbyStatus.textContent = `Waiting for Khushi to join (Code: ${ui.gameCodeDisplay.textContent})...`;
                        ui.lobbyStatus.className = "text-yellow-500 font-bold";
                    }
                }
            });
        }

        // --- Initialization ---

        const initFirebase = async () => {
            setLoading(true);
            try {
                if (!FIREBASE_CONFIG.apiKey) {
                    throw new Error("Missing Firebase API Key in FIREBASE_CONFIG.");
                }

                app = initializeApp(FIREBASE_CONFIG);
                db = getFirestore(app);
                auth = getAuth(app);

                await signInAnonymously(auth);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        ui.userIdDisplay.textContent = userId;
                        isGameReady = true;
                        startHistoryListener();
                        setLoading(false);
                    } else {
                        console.error("Authentication failed. Check Anonymous Auth in Firebase Console.");
                        showMessage("FATAL: Auth Failed. Check Anonymous sign-in method in your Firebase console.", 'bg-red-700 text-red-200');
                        setLoading(false);
                    }
                });

            } catch (e) {
                console.error("Firebase initialization or anonymous sign-in failed:", e);
                showMessage(`FATAL: Initialization Failed. Cause: ${e.message}. Ensure Anonymous Auth is ON.`, 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        // --- Event Listeners ---
        ui.createGameBtn.onclick = createGame;
        ui.joinGameBtn.onclick = () => joinGame(ui.gameIdInput.value.trim());

        window.onload = initFirebase;
    </script>
</head>
<body class="min-h-screen">
    <div id="loadingOverlay" class="overlay">
        <div class="flex flex-col items-center p-8 bg-gray-800 rounded-lg shadow-xl">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-pink-500 loading-spinner"></div>
            <p class="mt-4 text-xl text-pink-400 font-bold">Connecting to your Firebase...</p>
        </div>
    </div>

    <!-- Victory/Draw Modal Overlay -->
    <div id="winOverlay" class="overlay hidden">
        <div class="win-card">
            <h3 id="modalTitle" class="text-3xl font-extrabold text-white">üèÜ ROUND WIN! üèÜ</h3>
            <p id="modalMessage" class="modal-message khushi-color">Aww, Khushi won this round! Cutie tmhi jiti ho! ‚ú®</p>
            <button id="modalButton" class="bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white font-bold py-3 px-8 rounded-full transition duration-150 shadow-md transform hover:scale-105">
                Play Next Round
            </button>
        </div>
    </div>

    <div class="flex flex-col lg:flex-row max-w-7xl mx-auto py-4 space-y-8 lg:space-y-0 lg:space-x-8">

        <!-- GAME COLUMN (Left/Top) -->
        <div class="lg:w-1/2 w-full">
            <div class="container mb-6">
                <div class="vs-title font-extrabold mb-4">
                    <span class="shubham-color">SHUBHAM</span>
                    <span class="vs-comp">VS</span>
                    <span class="khushi-color">KHUSHI</span>
                </div>
                <h2 class="text-lg text-center text-gray-400 mb-6">Cross & Zero Dare Challenge! (First to 5 Wins)</h2>

                <div id="lobbySection" class="space-y-4">
                    <div class="flex flex-col items-center p-3 bg-gray-800 rounded-lg text-sm mb-4 border border-gray-700">
                        <p class="font-bold text-gray-300 mr-2">Your Firebase User ID:</p>
                        <code id="userIdDisplay" class="break-all text-blue-400 font-mono text-xs">Loading...</code>
                    </div>

                    <p id="lobbyStatus" class="text-center font-bold text-lg text-yellow-500">Awaiting connection...</p>
                    
                    <button id="createGameBtn" class="w-full bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white font-bold py-3 px-4 rounded-lg transition duration-150 shadow-lg transform hover:scale-[1.01]">
                        I'm Shubham! Create New Game ‚≠ê
                    </button>
                    
                    <div class="flex items-center space-x-2">
                        <input type="text" id="gameIdInput" placeholder="Enter Khushi's Access Code (e.g., LOVE)" class="flex-grow p-3 border-2 border-gray-700 bg-gray-900 text-white rounded-lg focus:outline-none focus:border-pink-500 uppercase" maxlength="4" />
                        <button id="joinGameBtn" class="bg-gradient-to-r from-pink-500 to-red-500 hover:from-pink-600 hover:to-red-600 text-white font-bold py-3 px-4 rounded-lg transition duration-150 shadow-lg transform hover:scale-[1.01] whitespace-nowrap">
                            I'm Khushi! Join Game üéÄ
                        </button>
                    </div>
                    
                    <p id="gameStatus" class="status-message bg-gray-700 text-gray-200">
                        Please create or join a game.
                    </p>
                </div>

                <!-- Game Section -->
                <div id="gameSection" class="hidden">
                    <!-- Status Box (Code/Connection Status) -->
                    <div id="statusBox" class="flex justify-between items-center mb-4 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <p class="text-sm font-medium text-gray-400">Your Role: <span id="yourPlayerName" class="font-bold text-lg shubham-color">?</span></p>
                        <p class="text-sm font-medium text-gray-400">Code: <span id="gameCodeDisplay" class="font-bold text-lg text-yellow-400 font-mono">????</span></p>
                        <p id="lobbyStatus" class="text-sm font-bold text-green-500">Khushi is Connected!</p>
                    </div>
                    

                    <div class="score-display">
                        <div class="score-box">
                            Shubham X
                            <div id="shubhamScore" class="score-value shubham-color">0</div>
                        </div>
                        <div class="score-box">
                            Khushi üéÄ
                            <div id="khushiScore" class="score-value khushi-color">0</div>
                        </div>
                    </div>
                    
                    <!-- Continuous Status Bar -->
                    <p id="gameStatus" class="status-message bg-gray-700 text-gray-200">Status will appear here.</p>

                    <!-- Game Board -->
                    <div id="boardContainer" class="board">
                        
                    </div>
                </div>
            </div>
        </div>

        <!-- HISTORY COLUMN (Right/Bottom) -->
        <div class="lg:w-1/2 w-full">
             <div class="container">
                <h3 class="text-2xl font-bold text-white mb-4 text-center">Last 20 Game History</h3>
                <p class="text-sm text-center text-gray-500 mb-4">Tracking wins for this epic challenge!</p>

                <div class="overflow-x-auto rounded-lg border border-gray-700">
                    <table class="w-full text-left history-table">
                        <thead>
                            <tr class="bg-gray-800">
                                <th class="p-3">#</th>
                                <th class="p-3">Winner</th>
                                <th class="p-3">Loser</th>
                                <th class="p-3">Time</th>
                            </tr>
                        </thead>
                        <tbody id="historyBody" class="divide-y divide-gray-700">
                            <tr><td colspan="4" class="p-4 text-center text-gray-500">Loading game history...</td></tr>
                        </tbody>
                    </table>
                </div>
             </div>
        </div>
    </div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khushi vs Shubham: Cross & Zero (Dare Edition)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Orbitron:wght@400;700;900&family=Pacifico&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* GitHub Dark Mode Black */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better scrolling/mobile view */
            min-height: 100vh;
            padding: 2rem 1rem;
            color: #e6edf3; /* Light text */
        }
        .main-grid {
            width: 100%;
            max-width: 1200px;
            display: grid;
            gap: 2rem;
            grid-template-columns: 1fr;
        }
        @media (min-width: 1024px) {
            .main-grid {
                grid-template-columns: 2fr 1fr; /* Game 2/3, History 1/3 on desktop */
            }
        }
        .card {
            background-color: #161b22; /* Darker card background */
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 255, 0.1); /* Subtle neon glow */
            border: 1px solid #30363d;
        }
        h1, h2, .score-value {
            font-family: 'Orbitron', sans-serif; /* Professional, futuristic font */
        }
        h1 {
            font-weight: 900;
        }
        .vs-comp {
            /* Neon red/cyan contrast */
            text-shadow: 0 0 5px #ff3366, 0 0 10px #ff3366;
            transition: all 0.2s ease-in-out;
            cursor: default;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 12px; 
            margin: 1.5rem 0;
        }
        .cell {
            aspect-ratio: 1 / 1;
            background-color: #1f242b; /* Cell background */
            border-radius: 8px; 
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            user-select: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
            border: 2px solid #30363d;
        }
        .cell:hover:not(.disabled) {
            background-color: #2b3038;
            transform: scale(1.05); 
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Stronger neon cyan glow on hover */
        }
        .cell.disabled {
            cursor: default;
        }
        /* Shubham is Star (X), Khushi is Hello Kitty (O) */
        .cell.mark-X {
            color: #00ffff; /* Neon Cyan for Shubham/Cute Star */
        }
        .cell.mark-O {
            color: #ff3366; /* Neon Pink/Red for Khushi/Hello Kitty */
        }
        .cell img {
            width: 80%;
            height: 80%;
            object-fit: contain;
            user-select: none;
            pointer-events: none; 
        }
        .status-message {
            font-size: 1.125rem;
            font-weight: 700;
            text-align: center;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            animation: fadeIn 0.5s ease-out;
            font-family: 'Inter', sans-serif;
        }
        .score-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 1.5rem;
            background-color: #0d1117;
            padding: 1rem 0;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        .score-box {
            text-align: center;
            font-size: 1.1rem;
            color: #8b949e;
        }
        .score-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #00ffff;
            margin-top: 0.25rem;
            text-shadow: 0 0 5px #00ffff50;
        }
        
        .history-table th {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            color: #00ffff;
            border-bottom: 1px solid #30363d;
            padding-bottom: 0.5rem;
        }
        .history-table td {
            font-size: 0.9rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid #1f242b;
        }
        .history-table tbody tr:last-child td {
            border-bottom: none;
        }
        .history-winner {
            color: #38a169; /* Green win */
        }
        .history-draw {
            color: #ecc94b; /* Yellow draw */
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 17, 23, 0.95); 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s;
            color: #00ffff;
        }
        .loading-spinner {
            animation: spin 1s linear infinite;
            border-color: #00ffff; 
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .btn-base {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            transition: all 0.2s ease-in-out;
        }
        .btn-base:hover {
            transform: translateY(-2px);
        }
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, getDoc, updateDoc, collection, query, limit, orderBy, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Permanent Firebase Configuration (Provided by user for project 'games-1c1f5')
        // Minimal config used to ensure Firebase Auth initializes correctly.
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyCnGV3jAxfcVze11wSfW_NzIS3z0rF8p6c",
            authDomain: "games-1c1f5.firebaseapp.com",
            projectId: "games-1c1f5",
        };
        const APP_ID = FIREBASE_CONFIG.projectId; 

        let app, db, auth, userId = null;
        let currentGameId = null;
        let playerMark = null; // 'X' or 'O'
        let unsubscribeGame = null;
        let unsubscribeHistory = null;
        let lastGameStatus = null; 

        // ROLES: Shubham creates (X), Khushi joins (O)
        const PLAYER_NAMES = {
            'X': 'Shubham', // Shubham is the Creator (Star)
            'O': 'Khushi'   // Khushi is the Joiner (Hello Kitty)
        };
        const WINNING_SCORE = 5;
        const HISTORY_LIMIT = 20;

        const ui = {
            gameIdInput: document.getElementById('gameIdInput'),
            userIdDisplay: document.getElementById('userIdDisplay'),
            lobbySection: document.getElementById('lobbySection'),
            gameSection: document.getElementById('gameSection'),
            createGameBtn: document.getElementById('createGameBtn'),
            joinGameBtn: document.getElementById('joinGameBtn'),
            gameStatus: document.getElementById('gameStatus'),
            boardContainer: document.getElementById('boardContainer'),
            yourPlayerName: document.getElementById('yourPlayerName'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            shubhamScoreDisplay: document.getElementById('shubhamScore'),
            khushiScoreDisplay: document.getElementById('khushiScore'),
            finalWinnerMessage: document.getElementById('finalWinnerMessage'),
            newRoundBtn: document.getElementById('newRoundBtn'),
            historyBody: document.getElementById('historyBody'),
            historyMessage: document.getElementById('historyMessage'),
        };

        const COLLECTIONS = {
            games: `artifacts/${APP_ID}/public/data/tictactoe_games_shubham_khushi_tts`,
            history: `artifacts/${APP_ID}/public/data/game_history`
        };

        const API_KEY = ""; 

        // --- Utility Functions ---

        const setLoading = (isLoading) => {
            ui.loadingOverlay.style.display = isLoading ? 'flex' : 'none';
        };

        const showMessage = (msg, colorClass) => {
            ui.gameStatus.textContent = msg;
            ui.gameStatus.className = `status-message ${colorClass}`;
        };

        const getPlayerName = (mark) => PLAYER_NAMES[mark] || mark;
        const getOpponentName = (mark) => PLAYER_NAMES[mark === 'X' ? 'O' : 'X'] || (mark === 'X' ? 'O' : 'X');

        const checkWinner = (board) => {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a]; // Returns 'X' or 'O'
                }
            }

            if (board.every(cell => cell !== "")) {
                return 'DRAW';
            }

            return null;
        };

        // --- TTS Helper Functions (Uses gemini-2.5-flash-preview-tts) ---
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bytesPerSample = 2; // Int16
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            
            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);
            
            let offset = 0;

            const writeString = (s) => {
                for (let i = 0; i < s.length; i++) {
                    view.setUint8(offset + i, s.charCodeAt(i));
                }
                offset += s.length;
            };

            // RIFF chunk
            writeString('RIFF');
            view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4;
            writeString('WAVE');

            // fmt chunk
            writeString('fmt ');
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size
            view.setUint16(offset, 1, true); offset += 2;  // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, 16, true); offset += 2; // BitsPerSample (16)

            // data chunk
            writeString('data');
            view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4;

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        };

        const callTTSApi = async (text, voiceName = "Zephyr") => {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voiceName }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`TTS API failed: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 16000;
                        
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        
                        const audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.play();
                        return;
                    }
                } catch (error) {
                    if (attempt < 2) {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                    }
                }
            }
        };


        // --- UI Rendering ---

        const renderBoard = (board, game) => {
            ui.boardContainer.innerHTML = '';
            board.forEach((mark, index) => {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                
                if (mark === 'X') {
                    cell.classList.add('mark-X');
                    const img = document.createElement('img');
                    img.src = 'https://i.ibb.co/q7X4J1R/cute-star.png'; // Shubham/Star
                    img.alt = 'Shubham/Cute Star';
                    cell.appendChild(img);
                } else if (mark === 'O') {
                    cell.classList.add('mark-O');
                    const img = document.createElement('img');
                    img.src = 'https://i.ibb.co/3s0390d/hello-kitty-head.png'; // Khushi/Hello Kitty
                    img.alt = 'Khushi/Hello Kitty';
                    cell.appendChild(img);
                }

                const isPlayable = game.status === 'IN_PROGRESS' && game.turn === playerMark;
                const isEmpty = mark === "";
                
                if (isPlayable && isEmpty) {
                    cell.onclick = () => handleCellClick(index);
                } else {
                    cell.classList.add('disabled');
                }

                ui.boardContainer.appendChild(cell);
            });
        };

        const renderGameUI = (game) => {
            const { board, turn, status, khushiWins, shubhamWins, playerXId, playerOId } = game;

            // Only show game UI if user is part of the game
            if (!currentGameId || (playerXId !== userId && playerOId !== userId)) {
                ui.lobbySection.classList.remove('hidden');
                ui.gameSection.classList.add('hidden');
                return;
            }

            ui.lobbySection.classList.add('hidden');
            ui.gameSection.classList.remove('hidden');
            ui.yourPlayerName.textContent = getPlayerName(playerMark);
            ui.shubhamScoreDisplay.textContent = shubhamWins;
            ui.khushiScoreDisplay.textContent = khushiWins;
            ui.finalWinnerMessage.classList.add('hidden');
            ui.newRoundBtn.classList.add('hidden'); 

            let message = "";
            let colorClass = "bg-gray-700 text-gray-200";
            
            // --- Custom Win Logic ---
            if (status === 'X_WINS' || status === 'O_WINS') {
                const winnerMark = status === 'X_WINS' ? 'X' : 'O';
                const winnerName = getPlayerName(winnerMark);
                
                // Trigger TTS and record history only once per win
                if (lastGameStatus !== status) {
                    const ttsMessage = winnerName === 'Khushi' 
                        ? "Aww, Khushi won this round! Congratulations!" 
                        : "Shubham won this round, but Khushi is still the cutest!";
                    callTTSApi(ttsMessage);
                    recordGameHistory(game, winnerName, 'Win');
                }

                if (shubhamWins >= WINNING_SCORE || khushiWins >= WINNING_SCORE) {
                    const finalWinnerName = shubhamWins >= WINNING_SCORE ? 'Shubham' : 'Khushi';
                    ui.finalWinnerMessage.textContent = `${finalWinnerName} wins the series! Time for a dare! üòâ`;
                    ui.finalWinnerMessage.classList.remove('hidden');
                    message = "Series Over!";
                    colorClass = "bg-purple-600 text-white";
                    ui.newRoundBtn.textContent = "Start New Game Series";
                } else {
                    // Custom Khushi/Shubham win messages
                    if (winnerMark === 'X') { // Shubham (X) won
                        if (playerMark === 'X') { // Shubham's Screen (Shubham won, but he shows Khushi won)
                            message = "Khushi hi jiti hai ü•∫"; 
                        } else { // Khushi's Screen (Khushi didn't win, but she sees this sweet message)
                            message = "Cutie tmhi jiti ho üòç"; 
                        }
                    } else { // Khushi (O) won
                        // Khushi won, so both see the generic sweet message
                        message = "Aww, Khushi won this round! Cutie tmhi jiti ho! ‚ú®";
                    }
                    colorClass = (winnerMark === playerMark) ? "bg-green-600 text-white" : "bg-red-600 text-white";
                    ui.newRoundBtn.textContent = "Play Next Round";
                }
                ui.newRoundBtn.classList.remove('hidden');
            } else if (status === 'DRAW') {
                if (lastGameStatus !== status) {
                    recordGameHistory(game, 'Draw', 'Draw');
                }
                message = "It's a Draw this round! ü§ù";
                colorClass = "bg-yellow-600 text-white";
                ui.newRoundBtn.textContent = "Play Next Round";
                ui.newRoundBtn.classList.remove('hidden');
            } else {
                switch (status) {
                    case 'LOBBY':
                        message = `Waiting for ${getOpponentName(playerMark)} to join...`;
                        colorClass = "bg-blue-800 text-blue-200";
                        break;
                    case 'IN_PROGRESS':
                        if (turn === playerMark) {
                            message = `Your turn, ${getPlayerName(playerMark)}! Execute!`;
                            colorClass = "bg-green-700 text-white";
                        } else {
                            message = `Awaiting ${getPlayerName(turn)}'s move...`;
                            colorClass = "bg-gray-700 text-gray-200";
                        }
                        break;
                }
            }

            showMessage(message, colorClass);
            renderBoard(board, game);
            lastGameStatus = status; // Update status tracker
        };
        
        // --- History System Functions ---

        const recordGameHistory = async (game, result, type) => {
            const historyRef = collection(db, COLLECTIONS.history);

            let resultString = '';
            let winnerId = null;

            if (type === 'Draw') {
                resultString = 'Draw';
            } else {
                const winnerMark = result === PLAYER_NAMES['X'] ? 'X' : 'O';
                winnerId = winnerMark === 'X' ? game.playerXId : game.playerOId;
                const loserName = winnerMark === 'X' ? PLAYER_NAMES['O'] : PLAYER_NAMES['X'];
                resultString = `${result} defeated ${loserName}`;
            }

            const historyEntry = {
                shubham: game.playerXId,
                khushi: game.playerOId,
                shubhamWins: game.shubhamWins,
                khushiWins: game.khushiWins,
                result: resultString,
                timestamp: Date.now(),
            };

            try {
                // Add new history entry
                await addDoc(historyRef, historyEntry);
            } catch (e) {
                console.error("Error recording history:", e);
            }
        };

        const renderHistory = (history) => {
            ui.historyBody.innerHTML = '';
            
            if (history.length === 0) {
                ui.historyMessage.textContent = 'No games recorded yet.';
                return;
            }

            ui.historyMessage.textContent = '';
            
            history.forEach(entry => {
                const row = document.createElement('tr');
                
                let resultClass = '';
                let resultText = '';

                if (entry.result === 'Draw') {
                    resultText = 'Draw ü§ù';
                    resultClass = 'history-draw';
                } else if (entry.result.includes('Shubham')) {
                    resultText = 'Shubham ‚≠ê';
                    resultClass = 'history-winner text-blue-400';
                } else {
                    resultText = 'Khushi üéÄ';
                    resultClass = 'history-winner text-pink-400';
                }

                const date = new Date(entry.timestamp).toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', day: '2-digit', month: 'short' });

                row.innerHTML = `
                    <td class="text-left py-2 px-1 text-gray-400">${date}</td>
                    <td class="text-center py-2 px-1 font-bold ${resultClass}">${resultText}</td>
                `;
                ui.historyBody.appendChild(row);
            });
        };

        // --- Firestore Operations ---

        const getGameDocRef = (id) => doc(db, COLLECTIONS.games, id);

        const createGame = async () => {
            currentGameId = userId; 
            playerMark = 'X'; // Creator is Shubham (X)
            setLoading(true);

            const initialGame = {
                board: ["", "", "", "", "", "", "", "", ""],
                currentPlayer: 'X',
                status: 'LOBBY',
                playerXId: userId,
                playerOId: null,
                turn: 'X',
                shubhamWins: 0,
                khushiWins: 0,
                lastUpdated: Date.now()
            };

            try {
                await setDoc(getGameDocRef(currentGameId), initialGame);
                showMessage('Game created! Share your User ID with Khushi.', 'bg-teal-700 text-teal-200');
                startRealTimeListener(currentGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Error creating game. See console.", 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        const joinGame = async (gameId) => {
            if (!gameId) {
                showMessage("Please enter Shubham's User ID.", 'bg-red-700 text-red-200');
                return;
            }

            setLoading(true);
            currentGameId = gameId;

            try {
                const gameRef = getGameDocRef(gameId);
                const docSnap = await getDoc(gameRef);

                if (!docSnap.exists()) {
                    showMessage("Game not found or invalid ID.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }

                const game = docSnap.data();

                if (game.playerXId === userId) {
                    playerMark = 'X'; // Rejoining as Shubham (X)
                    startRealTimeListener(gameId);
                    return;
                }

                if (game.playerOId && game.playerOId !== userId) {
                    showMessage("Game already full.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }

                // Joining as Khushi (O)
                playerMark = 'O';
                await updateDoc(gameRef, {
                    playerOId: userId,
                    status: 'IN_PROGRESS'
                });
                startRealTimeListener(gameId);

            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Error joining game. See console.", 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        const handleCellClick = async (index) => {
            if (!currentGameId || !playerMark) return;

            setLoading(true);
            const gameRef = getGameDocRef(currentGameId);
            const docSnap = await getDoc(gameRef);
            
            if (!docSnap.exists()) {
                setLoading(false);
                return;
            }
            
            const game = docSnap.data();
            const { board, turn, status } = game;

            if (status !== 'IN_PROGRESS' || turn !== playerMark || board[index] !== "") {
                setLoading(false);
                return; 
            }

            // 1. Update the board
            const newBoard = [...board];
            newBoard[index] = playerMark;

            // 2. Check for winner/draw
            const winner = checkWinner(newBoard);
            let newStatus = 'IN_PROGRESS';
            let nextTurn = playerMark === 'X' ? 'O' : 'X';
            
            let shubhamWins = game.shubhamWins;
            let khushiWins = game.khushiWins;

            if (winner === 'DRAW') {
                newStatus = 'DRAW';
                nextTurn = null; 
            } else if (winner) {
                newStatus = winner === 'X' ? 'X_WINS' : 'O_WINS';
                if (winner === 'X') shubhamWins++;
                else khushiWins++;
                nextTurn = null; 
            }

            // 3. Commit the state update
            try {
                await updateDoc(gameRef, {
                    board: newBoard,
                    turn: nextTurn,
                    status: newStatus,
                    shubhamWins: shubhamWins,
                    khushiWins: khushiWins,
                    lastUpdated: Date.now()
                });
            } catch (e) {
                console.error("Error making move:", e);
                showMessage("Move failed. Try again.", 'bg-red-700 text-red-200');
            } finally {
                setLoading(false);
            }
        };
        
        const resetRound = async (keepScore = true) => {
            if (!currentGameId) return;
            setLoading(true);

            const gameRef = getGameDocRef(currentGameId);
            const docSnap = await getDoc(gameRef);
            const game = docSnap.data();

            const updateData = {
                board: ["", "", "", "", "", "", "", "", ""],
                status: 'IN_PROGRESS',
                turn: 'X', // X (Shubham) always starts the next round
                lastUpdated: Date.now()
            };

            if (!keepScore) {
                updateData.shubhamWins = 0;
                updateData.khushiWins = 0;
            }

            try {
                await updateDoc(gameRef, updateData);
            } catch (error) {
                console.error("Error resetting game/round:", error);
            } finally {
                setLoading(false);
            }
        }


        // --- Real-Time Listeners ---

        const startRealTimeListener = (gameId) => {
            // Stop previous game listener if active
            if (unsubscribeGame) {
                unsubscribeGame();
            }

            const gameRef = getGameDocRef(gameId);
            
            unsubscribeGame = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const game = docSnap.data();
                    renderGameUI(game);
                    if (game.status !== 'LOBBY' || game.playerOId || game.playerXId) {
                        setLoading(false);
                    }
                } else {
                    showMessage("Game deleted or disconnected.", 'bg-red-700 text-red-200');
                }
            }, (error) => {
                console.error("Firestore snapshot error:", error);
                showMessage("Connection error. Try refreshing.", 'bg-red-700 text-red-200');
                setLoading(false);
            });
        };

        const startHistoryListener = () => {
            if (unsubscribeHistory) {
                unsubscribeHistory();
            }
            const historyCollectionRef = collection(db, COLLECTIONS.history);
            // Query the last 20 games by timestamp descending
            // Note: Firebase warns against orderBy without an index, so we sort client-side after fetching.
            const historyQuery = query(historyCollectionRef, limit(HISTORY_LIMIT));

            unsubscribeHistory = onSnapshot(historyQuery, (snapshot) => {
                const rawHistory = snapshot.docs.map(doc => doc.data());
                // Sort client-side by timestamp DESC
                const sortedHistory = rawHistory.sort((a, b) => b.timestamp - a.timestamp);
                renderHistory(sortedHistory);
            }, (error) => {
                console.error("History snapshot error:", error);
                ui.historyMessage.textContent = 'Failed to load history.';
            });
        };


        // --- Initialization ---

        const initFirebase = async () => {
            setLoading(true);
            
            try {
                app = initializeApp(FIREBASE_CONFIG);
                db = getFirestore(app);
                auth = getAuth(app);

                const userCredential = await signInAnonymously(auth);
                userId = userCredential.user.uid;
                
                ui.userIdDisplay.textContent = userId;
                ui.gameIdInput.value = userId; 
                setLoading(false);
                
                startHistoryListener();

            } catch (e) {
                console.error("Firebase initialization or anonymous sign-in failed:", e);
                // The explicit message for the user, in case they missed the manual setup
                showMessage("CRITICAL ERROR: Please ensure **Anonymous Sign-in** is **ENABLED** (Auth > Sign-in method) AND your **Firestore rules** are set correctly for /tictactoe_games_shubham_khushi_tts and /game_history.", 'bg-red-700 text-white font-bold');
                setLoading(false);
            }
        };

        // --- Event Listeners ---
        ui.createGameBtn.onclick = createGame;
        ui.joinGameBtn.onclick = () => joinGame(ui.gameIdInput.value.trim());
        ui.newRoundBtn.onclick = () => {
            const gameRef = getGameDocRef(currentGameId);
            getDoc(gameRef).then(docSnap => {
                if (docSnap.exists()) {
                    const game = docSnap.data();
                    // Check if series is over (5 wins)
                    const keepScore = !(game.shubhamWins >= WINNING_SCORE || game.khushiWins >= WINNING_SCORE);
                    resetRound(keepScore);
                }
            });
        };

        window.onload = initFirebase;
    </script>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-00ffff loading-spinner"></div>
        <p class="ml-4 text-lg text-00ffff font-orbitron">Connecting to your secure server...</p>
    </div>

    <div class="main-grid">
        <!-- Game Area Card (Left/Top) -->
        <div class="card">
            <h1 class="text-3xl font-extrabold text-center mb-1 flex justify-center items-baseline">
                <span class="text-blue-400 mr-2 text-4xl">SHUBHAM</span>
                <span class="text-4xl text-red-600 mx-1 font-extrabold vs-comp">VS</span>
                <span class="text-pink-400 ml-2 text-4xl">KHUSHI</span>
            </h1>
            <h2 class="text-xl font-semibold text-center text-gray-400 mb-6">
                THE DARE CHALLENGE
            </h2>
            
            <div class="p-3 bg-gray-800 rounded-lg text-sm mb-4 border border-gray-600 font-mono">
                <p class="font-bold text-gray-300">YOUR ID (Game Host Key):</p>
                <code id="userIdDisplay" class="break-all text-blue-400 font-bold mt-1 block text-lg">Loading...</code>
            </div>
            
            <!-- Lobby Section --><div id="lobbySection" class="space-y-4">
                <h2 class="text-xl font-semibold text-center text-gray-200 font-orbitron">BATTLE SETUP</h2>
                
                <button id="createGameBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white btn-base font-bold py-3 px-4 rounded-lg shadow-md hover:shadow-blue-500/50">
                    I'm Shubham! Create New Game ‚≠ê
                </button>

                <div class="flex items-center space-x-2">
                    <input type="text" id="gameIdInput" placeholder="Enter Shubham's ID to Join" class="flex-grow p-3 border-2 border-gray-600 bg-gray-700 text-white rounded-lg focus:outline-none focus:border-pink-500 font-inter" />
                    <button id="joinGameBtn" class="bg-pink-500 hover:bg-pink-600 text-white btn-base font-bold py-3 px-4 rounded-lg shadow-md hover:shadow-pink-500/50 whitespace-nowrap">
                    I'm Khushi! Join Game üéÄ
                    </button>
                </div>
                <p id="gameStatus" class="status-message bg-gray-700 text-gray-200">
                    Awaiting connection.
                </p>
            </div>

            <!-- Game Section --><div id="gameSection" class="hidden">
                <div class="text-center mb-4">
                    <p class="text-lg font-medium">Player: <span id="yourPlayerName" class="font-bold text-xl text-00ffff">?</span></p>
                </div>

                <div class="score-display">
                    <div class="score-box">
                        <span class="text-blue-400">SHUBHAM ‚≠ê</span>
                        <div id="shubhamScore" class="score-value text-blue-400">0</div>
                    </div>
                    <div class="score-box">
                        <span class="text-pink-400">KHUSHI üéÄ</span>
                        <div id="khushiScore" class="score-value text-pink-400">0</div>
                    </div>
                </div>
                
                <p id="gameStatus" class="status-message bg-gray-700 text-gray-200">Status will appear here.</p>
                <p id="finalWinnerMessage" class="status-message bg-purple-600 text-white font-extrabold text-xl hidden font-inter"></p>

                <div id="boardContainer" class="board">
                    <!-- Tic-Tac-Toe cells will be rendered here by JS --></div>

                <button id="newRoundBtn" class="w-full bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white btn-base font-bold py-3 px-4 rounded-lg shadow-md hover:shadow-green-500/50 hidden">
                    Play Next Round
                </button>
            </div>
        </div>

        <!-- History Card (Right/Bottom) -->
        <div class="card">
            <h2 class="text-2xl font-bold mb-4 text-00ffff border-b border-gray-700 pb-2 font-orbitron">
                BATTLE HISTORY (Last 20)
            </h2>
            <p id="historyMessage" class="text-center text-gray-500 italic mb-4">Loading history...</p>
            <div class="overflow-x-auto">
                <table class="w-full history-table">
                    <thead>
                        <tr>
                            <th class="text-left py-2 px-1">TIME</th>
                            <th class="text-center py-2 px-1">WINNER</th>
                        </tr>
                    </thead>
                    <tbody id="historyBody">
                        <!-- History rows populated by JS -->
                    </tbody>
                </table>
            </div>
        </div>

    </div>
</body>
</html>

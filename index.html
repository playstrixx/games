<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khushi vs Shubham: Cross & Zero (Dare Edition)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Pacifico&display=swap');
        
        /* Base Styles and Colors */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Very Dark Background */
            color: #c9d1d9; /* Light Gray Text */
            padding: 0.5rem; 
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 500px; 
            background-color: #161b22; 
            padding: 1rem; 
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(255, 255, 255, 0.05);
            margin: 0.5rem auto;
        }
        
        /* Competitive Title Styling */
        .vs-title {
            font-size: 2rem;
            line-height: 1.1;
            text-align: center;
        }
        @media (min-width: 640px) {
            .vs-title {
                font-size: 3rem;
            }
        }

        .shubham-color { color: #58a6ff; } /* Blue/Cyan */
        .khushi-color { color: #ff7aa2; } /* Pink/Rose */
        .vs-comp {
            color: #f85149; /* Bright Red */
            text-shadow: 0 0 10px rgba(248, 81, 73, 0.8);
            padding: 0 0.5rem;
        }

        /* Board Styles */
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 8px;
            margin: 1.5rem 0;
            border-radius: 12px;
            padding: 8px;
            background: #0d1117; 
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }
        .cell {
            aspect-ratio: 1 / 1;
            background-color: #21262d; 
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem; 
            font-weight: 900;
            cursor: pointer;
            transition: background-color 0.15s, transform 0.15s, box-shadow 0.15s;
            user-select: none;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        @media (min-width: 640px) {
            .cell {
                font-size: 3.5rem;
            }
        }
        .cell:hover:not(.disabled) {
            background-color: #30363d;
            transform: scale(1.03); 
            box-shadow: 0 0 12px rgba(88, 166, 255, 0.5); 
        }
        
        /* Mark Styles */
        .cell.mark-X { color: #58a6ff; } 
        .cell.mark-O img {
            width: 80%;
            height: 80%;
            object-fit: contain;
            border-radius: 50%;
            animation: popIn 0.3s ease-out;
        }

        /* Loading Overlay (Smoother look) */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 17, 23, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5000;
        }
        .loading-spinner {
            border-color: #ff7aa2; /* Pink spinner */
        }
        .loading-text {
            color: #ff7aa2;
        }
        
        /* Modal Styles */
        .win-card {
            box-shadow: 0 0 20px rgba(255, 122, 162, 0.9); 
        }
        .score-display {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 1.5rem;
            background-color: #0d1117;
            padding: 0.75rem;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        .score-value {
            font-family: 'Pacifico', cursive;
            font-size: 2.2rem;
            font-weight: bold;
            color: #fbd38d;
            margin-top: 0.25rem;
        }
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, getDoc, updateDoc, collection, query, limit, addDoc, where, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Permanent Firebase Configuration (Provided by user for project 'games-1c1f5')
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyCnGV3jAxfcVze11wSfW_NzIS3z0rF8p6c",
            authDomain: "games-1c1f5.firebaseapp.com",
            projectId: "games-1c1f5",
        };
        const APP_ID = FIREBASE_CONFIG.projectId; 

        let app, db, auth, userId = null;
        let currentGameId = null;
        let playerMark = null; // 'X' or 'O'
        let unsubscribeGame = null;
        let unsubscribeCodes = null;
        let lastGameStatus = null; 
        
        // ROLES: Shubham creates (X), Khushi joins (O)
        const PLAYER_NAMES = {
            'X': 'Shubham', // Creator (Star)
            'O': 'Khushi'   // Joiner (Hello Kitty)
        };
        const WINNING_SCORE = 5;
        const KITTY_IMAGE_URL = "https://i.ibb.co/39txdnyX/images.webp";
        const API_KEY = ""; // TTS API key placeholder

        const ui = {
            gameIdInput: document.getElementById('gameIdInput'),
            userIdDisplay: document.getElementById('userIdDisplay'),
            lobbySection: document.getElementById('lobbySection'),
            gameSection: document.getElementById('gameSection'),
            createGameBtn: document.getElementById('createGameBtn'),
            joinGameBtn: document.getElementById('joinGameBtn'),
            gameStatus: document.getElementById('gameStatus'),
            boardContainer: document.getElementById('boardContainer'),
            yourPlayerName: document.getElementById('yourPlayerName'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            shubhamScoreDisplay: document.getElementById('shubhamScore'),
            khushiScoreDisplay: document.getElementById('khushiScore'),
            winOverlay: document.getElementById('winOverlay'),
            modalTitle: document.getElementById('modalTitle'),
            modalMessage: document.getElementById('modalMessage'),
            modalButton: document.getElementById('modalButton'),
            lobbyStatus: document.getElementById('lobbyStatus'),
            gameCodeDisplay: document.getElementById('gameCodeDisplay'),
            sendDareBtn: document.getElementById('sendDareBtn'), // New Dare Button
        };

        const COLLECTIONS = {
            games: `artifacts/${APP_ID}/public/data/tictactoe_games_shubham_khushi_tts`,
            codes: `artifacts/${APP_ID}/public/data/game_codes`
        };

        // --- Utility Functions ---

        const setLoading = (isLoading) => {
            ui.loadingOverlay.style.display = isLoading ? 'flex' : 'none';
        };

        const showMessage = (msg, colorClass) => {
            ui.gameStatus.textContent = msg;
            ui.gameStatus.className = `status-message ${colorClass}`;
        };

        const getPlayerName = (mark) => PLAYER_NAMES[mark] || mark;
        const getOpponentName = (mark) => PLAYER_NAMES[mark === 'X' ? 'O' : 'X'] || (mark === 'X' ? 'O' : 'X');

        const checkWinner = (board) => {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a]; // Returns 'X' or 'O'
                }
            }

            if (board.every(cell => cell !== "")) {
                return 'DRAW';
            }

            return null;
        };
        
        // --- Access Code System ---
        const generateCode = () => {
            const words = ["LOVE", "HUG", "CUTE", "STAR", "ROSE", "HEART", "KISS", "KITT", "MWAH", "XOXO"];
            return words[Math.floor(Math.random() * words.length)];
        };

        const findGameIdByCode = async (code) => {
            const codesRef = collection(db, COLLECTIONS.codes);
            const q = query(codesRef, where("code", "==", code.toUpperCase()), limit(1));
            const snapshot = await getDocs(q);
            if (!snapshot.empty) {
                return snapshot.docs[0].data().gameId;
            }
            return null;
        };

        // --- TTS Helper Functions (Copied for single file integrity) ---
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };

        const pcmToWav = (pcm16, sampleRate) => {
            const numChannels = 1;
            const bytesPerSample = 2; // Int16
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            
            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);
            
            let offset = 0;

            const writeString = (s) => {
                for (let i = 0; i < s.length; i++) {
                    view.setUint8(offset + i, s.charCodeAt(i));
                }
                offset += s.length;
            };

            // RIFF chunk
            writeString('RIFF');
            view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4;
            writeString('WAVE');

            // fmt chunk
            writeString('fmt ');
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size
            view.setUint16(offset, 1, true); offset += 2;  // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, 16, true); offset += 2; // BitsPerSample (16)

            // data chunk
            writeString('data');
            view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4;

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        };

        const callTTSApi = async (text, voiceName = "Zephyr") => {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voiceName }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`TTS API failed: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 16000;
                        
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        
                        const audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.play();
                        return;
                    }
                } catch (error) {
                    if (attempt < 2) {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                    }
                }
            }
        };

        // --- UI Rendering ---

        const renderBoard = (board, game) => {
            ui.boardContainer.innerHTML = '';
            board.forEach((mark, index) => {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                
                if (mark === 'X') {
                    cell.classList.add('mark-X');
                    cell.textContent = 'X'; // Shubham is simple X
                } else if (mark === 'O') {
                    cell.classList.add('mark-O');
                    const img = document.createElement('img');
                    img.src = KITTY_IMAGE_URL; 
                    img.alt = 'Khushi/Hello Kitty';
                    cell.appendChild(img);
                }

                const isPlayable = game.status === 'IN_PROGRESS' && game.turn === playerMark;
                const isEmpty = mark === "";
                
                if (isPlayable && isEmpty) {
                    cell.onclick = () => handleCellClick(index);
                } else {
                    cell.classList.add('disabled');
                }

                ui.boardContainer.appendChild(cell);
            });
        };
        
        const showWinOverlay = (title, message, isSeriesWin, onContinue) => {
            ui.modalTitle.textContent = title;
            ui.modalMessage.innerHTML = message; 
            ui.modalButton.textContent = isSeriesWin ? "Start New Game Series" : "Play Next Round";
            
            // Show/Hide Dare Button based on Series Win status
            ui.sendDareBtn.classList.add('hidden');
            if (isSeriesWin && seriesWinnerMark === playerMark) {
                 ui.sendDareBtn.classList.remove('hidden');
            }

            ui.modalButton.onclick = () => {
                ui.winOverlay.classList.add('hidden');
                onContinue();
            };
            ui.winOverlay.classList.remove('hidden');
        }


        let seriesWinnerMark = null;

        const renderGameUI = (game) => {
            const { board, turn, status, khushiWins, shubhamWins, playerOId, lastWinner } = game;

            // --- Status Box Update (Connection status) ---
            if (playerMark) {
                const code = ui.gameCodeDisplay.textContent;
                let statusText = "";
                let statusClass = "text-yellow-500";
                
                if (status === 'LOBBY' && !playerOId) {
                    statusText = `Waiting for Khushi to join...`;
                } else if (status === 'LOBBY' && playerOId) {
                     statusText = `Khushi is Connected! Game starting...`;
                     statusClass = "text-green-500";
                } else if (status === 'IN_PROGRESS') {
                    statusText = `Khushi is Connected!`;
                    statusClass = "text-green-500";
                }
                
                ui.lobbyStatus.innerHTML = statusText;
                ui.gameCodeDisplay.textContent = code;
                ui.lobbyStatus.className = statusClass + ' font-bold';
            }
            
            // Update UI visibility
            ui.lobbySection.classList.add('hidden');
            ui.gameSection.classList.remove('hidden');
            ui.yourPlayerName.textContent = getPlayerName(playerMark);
            ui.shubhamScoreDisplay.textContent = shubhamWins;
            ui.khushiScoreDisplay.textContent = khushiWins;
            
            let message = "";
            let colorClass = "bg-gray-700 text-gray-200";
            
            // --- Determine Series Win ---
            const isSeriesOver = shubhamWins >= WINNING_SCORE || khushiWins >= WINNING_SCORE;
            seriesWinnerMark = shubhamWins >= WINNING_SCORE ? 'X' : khushiWins >= WINNING_SCORE ? 'O' : null;

            if (isSeriesOver) {
                if (lastGameStatus !== status) {
                    const winnerName = getPlayerName(seriesWinnerMark);
                    const loserName = getOpponentName(seriesWinnerMark);
                    
                    showWinOverlay(
                        "üéâ SERIES VICTORY! üéâ",
                        `The score is ${shubhamWins} vs ${khushiWins}. **${winnerName}** wins the series! <br><br> Time for a dare! **${winnerName}** must give **${loserName}** a dare!`,
                        true,
                        () => resetRound(false) // Reset scores
                    );
                }
                message = "Game Over! Time for a dare.";
                colorClass = "bg-purple-600 text-white";
            } else if (status === 'X_WINS' || status === 'O_WINS' || status === 'DRAW') {
                const winnerMark = status === 'X_WINS' ? 'X' : status === 'O_WINS' ? 'O' : null;
                const winnerName = winnerMark ? getPlayerName(winnerMark) : null;
                
                // --- Custom Win Messages for Round Win ---
                let modalTitle = status === 'DRAW' ? "ü§ù ROUND DRAW ü§ù" : "üèÜ ROUND WIN! üèÜ";
                let modalMessage;
                let ttsMessage; 

                if (winnerMark === 'X') { // Shubham (X) won
                    if (playerMark === 'X') { // Shubham's Screen (Winner)
                        modalMessage = "Khushi hi jiti hai ü•∫"; 
                    } else { // Khushi's Screen (Loser)
                        modalMessage = "Cutie tmhi jiti ho üòç"; 
                    }
                    ttsMessage = "Shubham won the round, but Khushi is still the cutest!";
                } else if (winnerMark === 'O') { // Khushi (O) won
                    modalMessage = "Aww, Khushi won this round! Cutie tmhi jiti ho! ‚ú®";
                    ttsMessage = "Aww, Khushi won this round! Congratulations!";
                } else {
                    modalMessage = "You both fought hard! Great match.";
                    ttsMessage = "It's a draw. Get ready for the next round!";
                }
                
                // Show modal only if status just changed
                if (lastGameStatus !== status) {
                     showWinOverlay(
                        modalTitle,
                        modalMessage,
                        false,
                        () => resetRound(true, winnerMark) // Pass winnerMark to resetRound
                    );
                    
                    // Play sound on both screens, but only once per status change
                    if (status !== 'DRAW') {
                        callTTSApi(ttsMessage);
                    }
                }

                message = modalTitle;
                colorClass = (winnerMark === playerMark) ? "bg-green-500 text-white" : "bg-red-500 text-white";
                
            } else {
                // Game in progress or lobby
                if (status === 'LOBBY' && !playerOId && playerMark === 'X') {
                    message = `Share your code: ${ui.gameCodeDisplay.textContent}`;
                    colorClass = "bg-yellow-700 text-yellow-200";
                } else if (status === 'IN_PROGRESS') {
                    if (turn === playerMark) {
                        message = `Your turn, ${getPlayerName(playerMark)}!`;
                        colorClass = "bg-pink-700 text-pink-200";
                    } else {
                        message = `Waiting for ${getPlayerName(turn)} to move...`;
                        colorClass = "bg-blue-700 text-blue-200";
                    }
                } else if (status === 'LOBBY' && playerOId) {
                     message = "Game ready! Shubham starts.";
                     colorClass = "bg-green-700 text-green-200";
                } else if (status === 'LOBBY' && playerMark === 'O') {
                     message = "Joined game. Waiting for Shubham to start the round.";
                     colorClass = "bg-green-700 text-green-200";
                }
            }
            
            // Only update the continuous status message if the modal is NOT showing
            if (ui.winOverlay.classList.contains('hidden')) {
                showMessage(message, colorClass);
            }
            
            renderBoard(board, game);
            lastGameStatus = status; // Update status tracker
        };


        // --- Firestore Operations ---

        const getGameDocRef = (id) => doc(db, COLLECTIONS.games, id);

        const createGame = async () => {
            // FIX: Check if auth is ready before proceeding
            if (!userId) {
                showMessage("Authentication not ready. Please wait for the loading screen to disappear.", 'bg-red-700 text-white');
                return; 
            }
            
            const cuteCode = generateCode();
            const firstTurn = Math.random() < 0.5 ? 'X' : 'O'; // Randomize first turn
            
            currentGameId = userId; 
            playerMark = 'X'; // Creator is Shubham (X)
            setLoading(true);

            const initialGame = {
                board: ["", "", "", "", "", "", "", "", ""],
                currentPlayer: 'X',
                status: 'LOBBY',
                playerXId: userId,
                playerOId: null,
                turn: firstTurn, // Use randomized turn
                shubhamWins: 0,
                khushiWins: 0,
                lastUpdated: Date.now(),
                lastWinner: null,
            };

            try {
                // 1. Create the main game document
                await setDoc(getGameDocRef(currentGameId), initialGame);
                
                // 2. Map the cute code to the actual game ID (UID)
                await setDoc(doc(db, COLLECTIONS.codes, cuteCode), {
                    code: cuteCode,
                    gameId: currentGameId,
                    creatorId: userId,
                    timestamp: Date.now()
                });

                ui.gameCodeDisplay.textContent = cuteCode;
                startRealTimeListener(currentGameId);
                startLobbyListener(currentGameId);
                
                ui.lobbySection.classList.add('hidden');
                ui.gameSection.classList.remove('hidden');
                ui.yourPlayerName.textContent = getPlayerName(playerMark);
                
                showMessage(`Game created! Share this code: ${cuteCode}`, 'bg-teal-700 text-teal-200');

            } catch (error) {
                console.error("Error creating game:", error);
                showMessage("Error creating game. See console.", 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        const joinGame = async (code) => {
            if (!userId) {
                showMessage("Authentication not ready. Please wait for the loading screen to disappear.", 'bg-red-700 text-white');
                return; 
            }
            if (!code) {
                showMessage("Please enter the Cute Code.", 'bg-red-700 text-red-200');
                return;
            }

            setLoading(true);
            
            try {
                // 1. Find the actual Game ID (UID) using the cute code
                const gameId = await findGameIdByCode(code.toUpperCase());

                if (!gameId) {
                    showMessage("Invalid Code or Game Not Found.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }
                
                currentGameId = gameId;
                const gameRef = getGameDocRef(gameId);
                const docSnap = await getDoc(gameRef);

                if (!docSnap.exists()) {
                    showMessage("Game not found or invalid ID.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }

                const game = docSnap.data();

                if (game.playerXId === userId) {
                    playerMark = 'X'; // Rejoining as Shubham
                    ui.gameCodeDisplay.textContent = code.toUpperCase();
                    startRealTimeListener(gameId);
                    return;
                }

                if (game.playerOId && game.playerOId !== userId) {
                    showMessage("Game already full.", 'bg-red-700 text-red-200');
                    setLoading(false);
                    return;
                }

                // Joining as Khushi (O)
                playerMark = 'O';
                await updateDoc(gameRef, {
                    playerOId: userId,
                    status: 'IN_PROGRESS'
                });
                ui.gameCodeDisplay.textContent = code.toUpperCase();
                startRealTimeListener(gameId);

            } catch (error) {
                console.error("Error joining game:", error);
                showMessage("Error joining game. See console.", 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        const handleCellClick = async (index) => {
            if (!currentGameId || !playerMark) return;

            setLoading(true);
            const gameRef = getGameDocRef(currentGameId);
            const docSnap = await getDoc(gameRef);
            
            if (!docSnap.exists()) { setLoading(false); return; }
            
            const game = docSnap.data();
            const { board, turn, status } = game;

            if (status !== 'IN_PROGRESS' || turn !== playerMark || board[index] !== "") {
                setLoading(false);
                return; 
            }

            // 1. Update the board
            const newBoard = [...board];
            newBoard[index] = playerMark;

            // 2. Check for winner/draw
            const winner = checkWinner(newBoard);
            let newStatus = 'IN_PROGRESS';
            let nextTurn = playerMark === 'X' ? 'O' : 'X';
            
            let shubhamWins = game.shubhamWins;
            let khushiWins = game.khushiWins;
            let lastWinner = null;

            if (winner === 'DRAW') {
                newStatus = 'DRAW';
                nextTurn = null; 
            } else if (winner) {
                newStatus = winner === 'X' ? 'X_WINS' : 'O_WINS';
                if (winner === 'X') {
                    shubhamWins++;
                    lastWinner = 'X';
                } else {
                    khushiWins++;
                    lastWinner = 'O';
                }
                nextTurn = null; 
            }

            // 3. Commit the state update
            try {
                await updateDoc(gameRef, {
                    board: newBoard,
                    turn: nextTurn,
                    status: newStatus,
                    shubhamWins: shubhamWins,
                    khushiWins: khushiWins,
                    lastUpdated: Date.now(),
                    lastWinner: lastWinner // Store winner for next round turn logic
                });
            } catch (e) {
                console.error("Error making move:", e);
                showMessage("Move failed. Try again.", 'bg-red-700 text-red-200');
            } finally {
                setLoading(false);
            }
        };
        
        const resetRound = async (keepScore = true, winnerMark = null) => {
            if (!currentGameId) return;
            setLoading(true);

            // Determine who starts the next round: winner of last round, or X if draw/first round
            let nextStarter = winnerMark || 'X'; 
            
            const gameRef = getGameDocRef(currentGameId);
            const updateData = {
                board: ["", "", "", "", "", "", "", "", ""],
                status: 'IN_PROGRESS',
                turn: nextStarter, // Winner starts the next round
                lastUpdated: Date.now()
            };

            if (!keepScore) {
                updateData.shubhamWins = 0;
                updateData.khushiWins = 0;
                // Delete the code mapping to allow a new game series to be created later
                try {
                    const codesRef = collection(db, COLLECTIONS.codes);
                    const q = query(codesRef, where("gameId", "==", currentGameId));
                    const snapshot = await getDocs(q);
                    if (!snapshot.empty) {
                        snapshot.docs.forEach(async doc => {
                            if (!keepScore) await deleteDoc(doc.ref);
                        });
                    }
                } catch (e) {
                    console.error("Failed to delete old code mapping:", e);
                }
            }

            try {
                await updateDoc(gameRef, updateData);
                lastGameStatus = null; 
                
                // If scores were reset (series victory), hide the game section for the creator
                if (!keepScore && playerMark === 'X') {
                    currentGameId = null;
                    ui.lobbySection.classList.remove('hidden');
                    ui.gameSection.classList.add('hidden');
                    showMessage("Series finished. Ready to create a new game!", 'bg-teal-700 text-teal-200');
                }
            } catch (error) {
                console.error("Error resetting game/round:", error);
            } finally {
                setLoading(false);
            }
        }


        // --- Real-Time Listeners ---

        const startRealTimeListener = (gameId) => {
            if (unsubscribeGame) {
                unsubscribeGame();
            }

            const gameRef = getGameDocRef(gameId);
            
            unsubscribeGame = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const game = docSnap.data();
                    renderGameUI(game);
                    if (game.status !== 'LOBBY' || game.playerOId || game.playerXId) {
                        setLoading(false);
                    }
                } else {
                    showMessage("Game deleted or disconnected.", 'bg-red-700 text-red-200');
                }
            }, (error) => {
                console.error("Firestore snapshot error:", error);
                showMessage("Connection error. Try refreshing.", 'bg-red-700 text-red-200');
                setLoading(false);
            });
        };

        // Lobby listener for Khushi's connection status
        const startLobbyListener = (gameId) => {
            if (unsubscribeCodes) unsubscribeCodes();
            
            const gameRef = getGameDocRef(gameId);
            
            unsubscribeCodes = onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    const game = docSnap.data();
                    if (game.playerOId) {
                        ui.lobbyStatus.textContent = "Khushi is Connected! üéÄ Game Ready!";
                        ui.lobbyStatus.className = "text-green-500 font-bold";
                        if (unsubscribeCodes) unsubscribeCodes(); 
                    } else if (playerMark === 'X') {
                        ui.lobbyStatus.textContent = `Waiting for Khushi to join (Code: ${ui.gameCodeDisplay.textContent})...`;
                        ui.lobbyStatus.className = "text-yellow-500 font-bold";
                    }
                }
            });
        }

        // --- Initialization ---

        const initFirebase = async () => {
            setLoading(true);
            try {
                if (!FIREBASE_CONFIG.apiKey) {
                    throw new Error("Missing Firebase API Key in FIREBASE_CONFIG.");
                }

                app = initializeApp(FIREBASE_CONFIG);
                db = getFirestore(app);
                auth = getAuth(app);

                const userCredential = await signInAnonymously(auth);
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        ui.userIdDisplay.textContent = userId;
                        setLoading(false);
                    } else {
                        console.error("Authentication failed. Check Anonymous Auth in Firebase Console.");
                        showMessage("FATAL: Auth Failed. Check Anonymous sign-in method in your Firebase console.", 'bg-red-700 text-red-200');
                        setLoading(false);
                    }
                });

            } catch (e) {
                console.error("Firebase initialization or anonymous sign-in failed:", e);
                showMessage(`FATAL: Initialization Failed. Cause: ${e.message}. Ensure Anonymous Auth is ON.`, 'bg-red-700 text-red-200');
                setLoading(false);
            }
        };

        // --- Event Listeners ---
        ui.createGameBtn.onclick = createGame;
        ui.joinGameBtn.onclick = () => joinGame(ui.gameIdInput.value.trim());
        ui.modalButton.onclick = () => {
            const gameRef = getGameDocRef(currentGameId);
            getDoc(gameRef).then(docSnap => {
                if (docSnap.exists()) {
                    const game = docSnap.data();
                    const keepScore = !(game.shubhamWins >= WINNING_SCORE || game.khushiWins >= WINNING_SCORE);
                    // Pass the last winner to resetRound for turn order
                    const winnerMark = game.lastWinner || (game.status === 'DRAW' ? null : 'X'); 
                    resetRound(keepScore, winnerMark);
                }
            });
        };
        
        ui.sendDareBtn.onclick = () => {
            const winnerName = getPlayerName(seriesWinnerMark);
            const loserName = getOpponentName(seriesWinnerMark);
            const dareMessage = prompt(`You won the series, ${winnerName}! Enter the dare for ${loserName}:`);
            
            if (dareMessage) {
                alert(`Dare Sent to ${loserName}: "${dareMessage}"\n\n(Note: In a real app, this would be sent via a chat/notification system.)`);
            } else {
                alert("Dare cancelled.");
            }
        }

        window.onload = initFirebase;
    </script>
</head>
<body>
    <div id="loadingOverlay" class="overlay">
        <div class="flex flex-col items-center p-8 bg-gray-800 rounded-lg shadow-xl">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-pink-500 loading-spinner"></div>
            <p class="mt-4 text-xl text-pink-400 font-bold loading-text">Connecting to your Firebase...</p>
        </div>
    </div>

    <!-- Victory/Draw Modal Overlay -->
    <div id="winOverlay" class="overlay hidden">
        <div class="win-card">
            <h3 id="modalTitle" class="text-3xl font-extrabold text-white">üèÜ ROUND WIN! üèÜ</h3>
            <p id="modalMessage" class="modal-message khushi-color">Aww, Khushi won this round! Cutie tmhi jiti ho! ‚ú®</p>
            <button id="modalButton" class="bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white font-bold py-3 px-8 rounded-full transition duration-150 shadow-md transform hover:scale-105">
                Play Next Round
            </button>
            <!-- Dare Button (Hidden by default, only shown on SERIES WIN for the winner) -->
            <button id="sendDareBtn" class="w-full bg-gradient-to-r from-red-600 to-pink-600 hover:from-red-700 hover:to-pink-700 text-white font-bold py-3 px-8 rounded-full transition duration-150 shadow-md transform hover:scale-105 mt-3 hidden">
                üéÅ Send Dare to the Loser!
            </button>
        </div>
    </div>

    <div class="container">

        <!-- GAME HEADER -->
        <div class="vs-title font-extrabold mb-4">
            <span class="shubham-color">SHUBHAM</span>
            <span class="vs-comp">VS</span>
            <span class="khushi-color">KHUSHI</span>
        </div>
        <h2 class="text-lg text-center text-gray-400 mb-6">Cross & Zero Dare Challenge! (First to 5 Wins)</h2>

        <!-- Lobby Section -->
        <div id="lobbySection" class="space-y-4">
            <div class="flex flex-col items-center p-3 bg-gray-800 rounded-lg text-sm mb-4 border border-gray-700">
                <p class="font-bold text-gray-300 mr-2">Your Firebase User ID:</p>
                <code id="userIdDisplay" class="break-all text-blue-400 font-mono text-xs">Loading...</code>
            </div>

            <p id="lobbyStatus" class="text-center font-bold text-lg text-yellow-500">Awaiting connection...</p>
            
            <button id="createGameBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition duration-150 shadow-md hover:shadow-lg hover:shadow-blue-500/50">
                I'm Shubham! Create New Game ‚≠ê
            </button>
            
            <div class="flex items-center space-x-2">
                <input type="text" id="gameIdInput" placeholder="Enter Khushi's Access Code (e.g., LOVE)" class="flex-grow p-3 border-2 border-gray-700 bg-gray-900 text-white rounded-lg focus:outline-none focus:border-pink-500 uppercase" maxlength="4" />
                <button id="joinGameBtn" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-4 rounded-lg transition duration-150 shadow-md hover:shadow-lg hover:shadow-pink-500/50 whitespace-nowrap">
                    I'm Khushi! Join Game üéÄ
                </button>
            </div>
            
            <p id="gameStatus" class="status-message bg-gray-700 text-gray-200">
                Please create or join a game.
            </p>
        </div>

        <!-- Game Section -->
        <div id="gameSection" class="hidden">
            <!-- Status Box (Code/Connection Status) -->
            <div id="statusBox" class="flex justify-between items-center mb-4 p-3 bg-gray-900 rounded-lg border border-gray-700 flex-wrap gap-2">
                <p class="text-sm font-medium text-gray-400">Role: <span id="yourPlayerName" class="font-bold shubham-color">?</span></p>
                <p class="text-sm font-medium text-gray-400">Code: <span id="gameCodeDisplay" class="font-bold text-yellow-400 font-mono">????</span></p>
                <p id="lobbyStatus" class="text-sm font-bold text-green-500 flex-grow text-right">Khushi is Connected!</p>
            </div>
            

            <div class="score-display">
                <div class="score-box">
                    Shubham X
                    <div id="shubhamScore" class="score-value shubham-color">0</div>
                </div>
                <div class="score-box">
                    Khushi üéÄ
                    <div id="khushiScore" class="score-value khushi-color">0</div>
                </div>
            </div>
            
            <!-- Continuous Status Bar -->
            <p id="gameStatus" class="status-message bg-gray-700 text-gray-200">Status will appear here.</p>

            <!-- Game Board -->
            <div id="boardContainer" class="board">
                
            </div>
            
            <!-- Note: The main modal button is now used to continue the game flow -->
        </div>
    </div>
</body>
</html>
